# Docker And Kubernetes Practical Tasks

**Docker tasks**

**Practical Task 1: Install and Run a Docker Container**

**Requirements:**

- Install Docker on your local machine and verify the installation.
- Pull the official nginx Docker image from Docker Hub.
- Run the nginx container, mapping port 80 inside the container to port 8080 on your host machine.
- Verify the container is running by accessing the default Nginx page via a web browser at http://localhost:8080.

![Task](docker_install/nginx_run.png)

![Task](docker_install/nginx_test.png)

**Practical Task 2: Create and Build a Docker Image**

**Requirements:**

- Develop a simple "Hello World" web application using a language of your choice, such as Python with Flask or Node.js.
- Write a Dockerfile to containerize the application, specifying the base image, working directory, dependencies, and command to run the application.
- Build the Docker image locally from the Dockerfile and tag it appropriately.
- Run the containerized application and ensure it is accessible from your host machine.

Link to the flask app: https://github.com/prakhar1989/docker-curriculum.git

![Task](docker_image/dockerfile.png)

![Task](docker_image/test.png)

**Practical Task 3: Docker Compose for Multi-Container Applications**

**Requirements:**

1. Application Functionality:
  - a. Frontend:
    - i. Develop a simple frontend application using a framework like React or plain HTML/CSS/JavaScript.
    - ii. The UI should have a single button labeled "Get Quote."
    - iii. When the button is clicked, it should make an API call to the backend to retrieve a random quote and display it on the page.
  - b. Backend:
    - i. Develop a Node.js application using Express that provides an API endpoint.
    - ii. The application should include:
    - 1. GET /quote: Return a random quote from a predefined list of hardcoded quotes.

2. Data Storage:
   - a. For this task, there's no need for a database service. The quotes can be hardcoded in the backend application.
3. Docker Compose Configuration:
   - a. Create a docker-compose.yml file to define the application architecture, including:
     - i. Frontend Service: A service running the frontend application, exposing port 8080 to the host.
     - ii. Backend Service: A Node.js service running the backend application, exposing port 3000 to the frontend service.
   - b. Configure environment variables and network settings to allow the frontend to communicate with the backend.
4. Networking:
   - a. Ensure both services are on the same Docker network to facilitate communication.
   - b. Verify that the frontend application can successfully make requests to the backend service using the configured network settings.
5. Build and Run:
   - a. Use Docker Compose to build and run the application, ensuring both services start correctly.
   - b. Test the application by clicking the "Get Quote" button and verifying that a random quote is displayed on the frontend.

[quote-app](docker_compose/quote-app)

![Task](docker_compose/backend-dockerfile.png)

![Task](docker_compose/frontend-dockerfile.png)

![Task](docker_compose/docker-compose.png)

![Task](docker_compose/react_app.png)

**Practical Task 4: Docker Networking for Multi-Container Applications**

**Requirements:**

Application Functionality:
  - Use the same frontend and backend applications from Practical Task 3.
  - Ensure the frontend application can communicate with the backend using a Docker network.
Docker Networking:
  - Create a custom Docker network to facilitate communication between the frontend and backend services.
  - Deploy both services on this network and ensure the frontend can access the backend API endpoint.
Verification:
  - Verify that the frontend application can successfully retrieve and display random quotes by making requests to the backend over the custom network.

![Task](network/inspect_network.png)

**Practical Task 5: Docker Volumes for Persistent Storage**

**Requirements:**

Application Functionality:
 - Extend the backend application from Practical Task 3 to log each quote request to a file for auditing purposes.
Data Storage:
 -  Use a Docker volume to persist the log file generated by the backend service.Ensure that the log data is retained even if the backend container is stopped or removed.
Docker Compose Configuration:
 - Update the docker-compose.yml file to include a volume for the backend service.
 - Mount the volume to a directory in the backend container where the log file will be stored.
Verification:
 - Test the application by making multiple requests from the frontend and checking the log file for entries.

![Task](volume/logs.png)

![Task](volume/logs1.png)

![Task](volume/app_logs.png)

**Practical Task 6: Docker Swarm for Orchestration**

**Requirements:**

Application Functionality:
 - Use the same frontend and backend applications with logging functionality as in Practical Task 5.
Docker Swarm Setup:
 - Initialize a Docker Swarm cluster on your local machine or across multiple nodes.
 - Define a stack file (e.g., docker-stack.yml) to deploy the frontend and backend services with logging.
Deployment and Scaling:
 - Deploy the application stack to the Swarm cluster, ensuring services are distributed across available nodes.
 - Configure the stack to scale the backend service to multiple replicas to handle increased load.
Verification:
 - Verify load balancing by making multiple requests from the frontend and observing how requests are distributed across backend replicas.
 - Check that logging continues to function correctly across replicas, with log data being persisted using Docker volumes.

![Task](docker_swarm/swarm_init.png)

![Task](docker_swarm/stack.png)

![Task](docker_swarm/deploy.png)

![Task](docker_swarm/docker_ps.png)

![Task](docker_swarm/curl.png)

![Task](docker_swarm/exec.png)

![Task](docker_swarm/service.png)

**Kubernetes tasks**

**Practical Task 1: Set Up a Local Kubernetes Environment**

**Requirements:**

- Install a local Kubernetes environment using Minikube or Docker Desktop with Kubernetes enabled.
- Verify the installation by running kubectl commands to check the cluster status.
- Deploy a simple "Hello World" application using a Deployment resource.
- Expose the application using a Service of type NodePort and verify access from your local machine.

![Task](minikube_setup/test_controller.png)

![Task](minikube_setup/dockerfile.png)

![Task](minikube_setup/deployment.png)

![Task](minikube_setup/apply.png)

![Task](minikube_setup/test.png)

**Practical Task 2: Deploy a Multi-Container Application**

**Requirements:**

- Package the multi-container application from Docker Compose (frontend and backend) into Kubernetes Pods.
- Create Kubernetes Deployment resources for both the frontend and backend services.
- Use ConfigMaps and Secrets to manage environment variables and sensitive data, respectively.
- Expose both services using appropriate Service resources and verify communication between them.
- Note: Use the multi-container application developed in the Docker tasks (Practical Task 3).

![Task](multi-container/entrypoint.png)

![Task](multi-container/configmap.png)

![Task](multi-container/backend-depl.png)

![Task](multi-container/frontend_depl.png)

![Task](multi-container/svc.png)

![Task](multi-container/app.png)

**Practical Task 3: Implement Persistent Storage with Persistent Volumes**

**Requirements:**

- Extend the backend application to log requests and store these logs using Kubernetes Persistent Volumes.
- Create a PersistentVolume and PersistentVolumeClaim in Kubernetes to manage storage.
- Update the backend Deployment to mount the PersistentVolume and verify data persistence across Pod restarts.
- Note: Use the logging functionality from the Docker tasks for the backend application (Practical Task 3).

![Task](persistent_storage/volume_claim.png)

![Task](persistent_storage/depl.png)

![Task](persistent_storage/pv_pvc.png)

![Task](persistent_storage/pod_volume_check.png)

![Task](persistent_storage/pvc_pv_check.png)

![Task](persistent_storage/pvc_attach_to_pod.png)

![Task](persistent_storage/logs.png)

![Task](persistent_storage/node_logs.png)

![Task](persistent_storage/pod_restart.png)

**Practical Task 4: Scale Applications with Horizontal Pod Autoscaler**

**Requirements:**

- Deploy a stateless application that can be easily scaled.
- Configure a Horizontal Pod Autoscaler (HPA) to automatically scale the number of Pods based on CPU usage.
- Simulate load on the application and observe the scaling behavior.
- Note: Use the web application from the Docker tasks (Practical Task 3).

![Task](hpa/metrics_server_enable.png)

![Task](hpa/add_resources_depl.png)

![Task](hpa/hpa.png)

![Task](hpa/apply.png)

![Task](hpa/generate_load.png)

![Task](hpa/watch_scaling.png)

**Practical Task 5: Implement Ingress for External Access**

**Requirements:**

- Set up an Ingress Controller in your Kubernetes cluster.
- Create Ingress resources to manage external access to the frontend and backend services.
- Configure path-based routing to direct traffic to the appropriate service based on the URL path.
- Verify that the application is accessible via a single external IP or domain name.
- Note: Use the frontend and backend services from the Docker tasks (Practical Task 3).

![Task](ingress/ingress_manifest.png)

![Task](ingress/frontend.png)

![Task](ingress/backend_api.png)

**Practical Task 6: Deploy a Kubernetes Application with Helm**

**Requirements:**

- Install Helm, the Kubernetes package manager, in your local environment.
- Create a Helm chart for the multi-container application, including templates for Deployments, Services, and Ingress.
- Package and deploy the application using Helm.
- Update the application by modifying the Helm chart and redeploying, demonstrating Helm's upgrade capabilities.
- Note: Use the multi-container application from the Docker tasks (Practical Task 3) to create the Helm chart.

![Task](helm/helm_install.png)

![Task](helm/helm_list.png)

![Task](helm/namespace.png)

![Task](helm/configmap.png)

![Task](helm/backend.png)

![Task](helm/frontend.png)

![Task](helm/hpa.png)

![Task](helm/ingress.png)

![Task](helm/pv.png)

![Task](helm/deployment_v1.png)

![Task](helm/app_v1.png)

![Task](helm/update_backend.png)

![Task](helm/helm_upgrade.png)

![Task](helm/deployment_v2.png)

![Task](helm/app_v2.png)
